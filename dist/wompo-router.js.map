{
  "version": 3,
  "sources": ["../ts/wompo-router.ts"],
  "sourcesContent": ["import {\n\ttype LazyCallbackResult,\n\ttype LazyResult,\n\ttype RenderHtml,\n\ttype WompoComponent,\n\ttype WompoProps,\n\tcreateContext,\n\tdefineWompo,\n\tlazy,\n\tuseCallback,\n\tuseContext,\n\tuseEffect,\n\tuseMemo,\n\tuseState,\n\tSuspense,\n\thtml,\n} from 'wompo';\n\n/* \n================================================================\nHELPERS\n================================================================\n*/\nconst buildTreeStructure = (\n\torigin: string | null,\n\tchildNodes: Node[] | NodeList,\n\tstructure: RouteStructure[] = [],\n\tparent: RouteStructure = null\n): RouteStructure[] => {\n\tchildNodes.forEach((child) => {\n\t\tif (child instanceof (Route as WompoComponent).class) {\n\t\t\tconst props = child.props as RouteProps;\n\t\t\tconst lazyComp = props.lazy ? lazy(props.lazy) : null;\n\t\t\tconst path =\n\t\t\t\tparent === null && origin\n\t\t\t\t\t? (props.path.startsWith('/')\n\t\t\t\t\t\t\t? props.path.substring(0, props.path.length - 1)\n\t\t\t\t\t\t\t: props.path) + origin\n\t\t\t\t\t: props.path;\n\t\t\tconst route: RouteStructure = {\n\t\t\t\t...props,\n\t\t\t\tparent: parent,\n\t\t\t\telement: props.element,\n\t\t\t\tpath: path,\n\t\t\t\tlazy: lazyComp,\n\t\t\t\tfallback: props.fallback,\n\t\t\t\tindex: null,\n\t\t\t\tchildren: [],\n\t\t\t};\n\t\t\tif (props.index) parent.index = route;\n\t\t\tstructure.push(route);\n\t\t\tbuildTreeStructure(origin, child.childNodes, route.children, route);\n\t\t}\n\t});\n\treturn structure;\n};\n\nconst getRoutes = (\n\ttreeStructure: RouteStructure[],\n\tpaths: [string, RouteStructure][] = [],\n\tparent: string = ''\n) => {\n\tfor (const route of treeStructure) {\n\t\tlet newRoute = '';\n\t\tif (route.path) {\n\t\t\tconst slash =\n\t\t\t\t(parent && !parent.endsWith('/')) || (!parent && !route.path.startsWith('/')) ? '/' : '';\n\t\t\tnewRoute += parent + slash + route.path;\n\t\t\troute.fullPath = newRoute;\n\t\t\tpaths.push([newRoute, route]);\n\t\t}\n\t\tif (route.children) {\n\t\t\tgetRoutes(route.children, paths, newRoute);\n\t\t}\n\t}\n\treturn paths;\n};\n\ninterface Params {\n\tsegments?: string[];\n\tsearch?: { [key: string]: any };\n\t[key: string]: any;\n}\n\nconst getWichParametricRouteisMoreSpecific = (routes: Params) => {\n\tconst parametricPaths = Object.keys(routes);\n\tparametricPaths.sort((a, b) => {\n\t\tconst matchA = routes[a];\n\t\tconst matchB = routes[b];\n\t\tconst dynamicsA = Object.keys(matchA).filter((key) => key !== 'segments').length;\n\t\tconst dynamicsB = Object.keys(matchB).filter((key) => key !== 'segments').length;\n\t\tconst difference = dynamicsB - dynamicsA;\n\t\tif (difference === 0) {\n\t\t\tlet staticsA = a.split('/');\n\t\t\tlet staticsB = b.split('/');\n\t\t\tconst lengthDifference = staticsB.length - staticsA.length;\n\t\t\tif (lengthDifference !== 0) return lengthDifference;\n\t\t\tlet staticsALength = 0;\n\t\t\tlet staticsBLength = 0;\n\t\t\tfor (let i = 0; i < staticsA.length; i++) {\n\t\t\t\tconst sA = staticsA[i];\n\t\t\t\tconst sB = staticsB[i];\n\t\t\t\tif (!sA.startsWith(':')) staticsALength++;\n\t\t\t\tif (!sB.startsWith(':')) staticsBLength++;\n\t\t\t\tif (sA.startsWith(':') || sB.startsWith(':') || sA.startsWith('*') || sB.startsWith('*'))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn staticsBLength - staticsALength;\n\t\t}\n\t\treturn difference;\n\t});\n\treturn routes[parametricPaths[0]];\n};\n\nconst getSearchObject = (searchString: string) => {\n\tif (!searchString) return {};\n\tconst params: any = {};\n\tsearchString.split('&').forEach((el) => {\n\t\tconst [key, value] = el.split('=');\n\t\tparams[key] = value;\n\t});\n\treturn params;\n};\n\nconst getMatch = (\n\troutes: [string, RouteStructure][],\n\tbroswerRoute: string\n): [RouteStructure, Params] => {\n\tconst matches: {\n\t\texact?: RouteStructure;\n\t\tparametric?: Params;\n\t\tfallbacks?: Params;\n\t} = {\n\t\texact: null,\n\t\tparametric: {},\n\t\tfallbacks: {},\n\t};\n\tconst bRoute =\n\t\tbroswerRoute !== '/' && broswerRoute.endsWith('/')\n\t\t\t? broswerRoute.substring(0, broswerRoute.length - 1)\n\t\t\t: broswerRoute;\n\tconst [currentRoute, search] = bRoute.split('?');\n\tfor (const routeStructure of routes) {\n\t\tconst [routePath, route] = routeStructure;\n\t\tconst isFallback = routePath.endsWith('*');\n\t\tif (!isFallback && routePath.split('/').length !== currentRoute.split('/').length) continue;\n\t\tif (routePath === currentRoute) {\n\t\t\tmatches.exact = route;\n\t\t\tbreak;\n\t\t}\n\t\tif (!routePath.includes(':') && !routePath.includes('*')) continue;\n\t\tconst segments = routePath.split('/');\n\t\tlet regex = '';\n\t\t// Skips first element\n\t\tconst paramNames: string[] = [];\n\t\tfor (let i = 1; i < segments.length; i++) {\n\t\t\tconst segment = segments[i];\n\t\t\tregex += '\\\\/';\n\t\t\tif (segment.startsWith(':')) {\n\t\t\t\tif (i === segments.length - 1) regex += '(.*)';\n\t\t\t\telse regex += '(.*?)';\n\t\t\t\tparamNames.push(segment.substring(1));\n\t\t\t} else if (segment === '*') {\n\t\t\t\tregex += '(.*)?';\n\t\t\t\tparamNames.push('segments');\n\t\t\t} else {\n\t\t\t\tregex += segment;\n\t\t\t}\n\t\t}\n\t\tconst matchRegex = new RegExp(regex, 'g');\n\t\tconst routeToMatch =\n\t\t\tcurrentRoute + (regex.endsWith('(.*)?') && !currentRoute.endsWith('/') ? '/' : '');\n\t\tconst match = matchRegex.exec(routeToMatch);\n\t\tif (match) {\n\t\t\tconst params: Params = {};\n\t\t\t// Skips first element, which is the whole match\n\t\t\tfor (let i = 1; i < match.length; i++) {\n\t\t\t\tlet matchedSegment = match[i] ?? '';\n\t\t\t\tif (paramNames[i - 1] === 'segments') {\n\t\t\t\t\tconst segmentsParam = matchedSegment ? matchedSegment.split('/') : [];\n\t\t\t\t\tsegmentsParam.pop();\n\t\t\t\t\tparams[paramNames[i - 1]] = segmentsParam;\n\t\t\t\t} else {\n\t\t\t\t\tparams[paramNames[i - 1]] = matchedSegment;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (isFallback) matches.fallbacks[routePath] = [route, params];\n\t\t\telse matches.parametric[routePath] = [route, params];\n\t\t}\n\t}\n\tconst parametricPaths = Object.keys(matches.parametric);\n\tconst fallbackPaths = Object.keys(matches.fallbacks);\n\tlet match: [RouteStructure, Params] = [null, null];\n\tif (matches.exact) {\n\t\tmatch = [matches.exact, {}];\n\t} else if (parametricPaths.length) {\n\t\tmatch = getWichParametricRouteisMoreSpecific(matches.parametric);\n\t} else if (fallbackPaths.length) {\n\t\tmatch = getWichParametricRouteisMoreSpecific(matches.fallbacks);\n\t}\n\tconst redirect = match[0]?.redirect || match[0]?.index?.redirect;\n\tif (redirect) {\n\t\tconst newPath = getHref(redirect, match[0], match[1]);\n\t\thistory.replaceState({}, undefined, newPath);\n\t\tmatch = getMatch(routes, newPath);\n\t}\n\tif (match[1]) match[1].search = getSearchObject(search);\n\treturn match;\n};\n\nconst getRouteContent = (router: RouterContext) => {\n\tconst route = router.singleRoute;\n\treturn html`\n\t\t<${RouterContext.Provider} value=${router}>\n\t\t\t${\n\t\t\t\troute?.lazy\n\t\t\t\t\t? route.fallback\n\t\t\t\t\t\t? html`\n\t\t\t\t\t\t\t<${Suspense} fallback=${route.fallback}>\n\t\t\t\t\t\t\t\t<${route.lazy} />\n\t\t\t\t\t\t\t</${Suspense}>\n\t\t\t\t\t\t`\n\t\t\t\t\t\t: html`<${route.lazy} />`\n\t\t\t\t\t: route?.element\n\t\t\t}\n\t\t</${RouterContext.Provider}>\n\t`;\n};\n\n/* \n================================================================\nROUTES\n================================================================\n*/\ninterface RoutesProps extends WompoProps {\n\tnotFoundElement?: RenderHtml;\n\torigin?: string;\n}\n\ninterface RouteStructure extends Omit<RouteProps, 'index' | 'children' | 'lazy'> {\n\tparent: RouteStructure;\n\telement: RenderHtml;\n\tpath: string;\n\tfullPath?: string;\n\tchildren: RouteStructure[];\n\tindex: RouteStructure;\n\tnextRoute?: RouteStructure;\n\tfallback: RenderHtml;\n\tlazy: LazyResult;\n}\n\ninterface RouterContext {\n\tparams: Params;\n\thash?: string;\n\tcurrentRoute: string;\n\tsetNewRoute: (newValue: string, push?: boolean) => void;\n\troutes: [string, RouteStructure][];\n\troute: RouteStructure;\n\tsingleRoute: RouteStructure;\n}\nconst RouterContext = createContext<RouterContext>({\n\tparams: null,\n\thash: null,\n\tcurrentRoute: null,\n\tsetNewRoute: null,\n\troutes: [],\n\troute: null,\n\tsingleRoute: null,\n});\n\nconst scrollIntoView = (hash: string) => {\n\tif (hash) {\n\t\tconst element = document.getElementById(hash);\n\t\tif (element) element.scrollIntoView({ block: 'start', behavior: 'smooth' });\n\t}\n};\n\n/**\n * The main component to handle the client routing system.\n * It will iterate through all the children to find `Route` components so that it'll build all the\n * necessary routes.\n * The routes will be deleted after the first render and the content of the current route will be\n * displayed.\n *\n * It accepts the following props:\n * - notFoundElement: the component to render if the route current route is not found between the\n *   routes tree.\n * - origin: specifies the url location on where the routing starts (e.g. \"/admin\").\n *\n * Example:\n * ```javascript\n * function App(){\n *   return html`\n *     <${Routes}>\n * \t\t   <${Route} path=\"/\" component=${html`<${Home} />`} />\n * \t\t\t <${Route} path=\"/users\" component=${html`<${UsersDashboard} />`}>\n * \t\t\t\t <${Route} path=\":id\" component=${html`<${UserDetails} />`} />\n * \t\t\t\t <${Route} index component=${html`<${UsersList} />`} />\n * \t\t\t </${Route}>\n *     </${Routes}>\n *   `\n * }\n * ```\n */\nexport function Routes({ origin, notFoundElement, children }: RoutesProps) {\n\tconst [currentRoute, setCurrentRoute] = useState(\n\t\twindow.location.pathname + window.location.search\n\t);\n\n\tconst treeStructure = useMemo(() => {\n\t\tconst tree = buildTreeStructure(origin, children.nodes);\n\t\treturn tree;\n\t}, []);\n\n\tconst routes: [string, RouteStructure][] = useMemo(() => getRoutes(treeStructure), []);\n\tconst hash = window.location.hash.split('#')[1];\n\tconst [route, params] = getMatch(routes, currentRoute);\n\n\tconst setNewRoute = useCallback(\n\t\t(newRoute: string, pushState: boolean = true) => {\n\t\t\tsetCurrentRoute((prevRoute) => {\n\t\t\t\tconst nextRoute = getHref(newRoute, route, params);\n\t\t\t\tconst [pathname, hash] = nextRoute.split('#');\n\t\t\t\tif (pushState && prevRoute !== nextRoute) {\n\t\t\t\t\thistory.pushState({}, null, nextRoute);\n\t\t\t\t} else if (!pushState && prevRoute !== nextRoute) {\n\t\t\t\t\thistory.replaceState({}, null, nextRoute);\n\t\t\t\t}\n\t\t\t\tscrollIntoView(hash);\n\t\t\t\tif (!nextRoute.startsWith('#')) return pathname;\n\t\t\t\treturn prevRoute;\n\t\t\t});\n\t\t},\n\t\t[route, params]\n\t);\n\n\tuseEffect(() => {\n\t\twindow.addEventListener('popstate', () => {\n\t\t\tsetNewRoute(window.location.pathname, false);\n\t\t});\n\t}, []);\n\n\tuseEffect(() => {\n\t\twindow.scrollTo(0, 0);\n\t\tif (route?.lazy) {\n\t\t\troute.lazy().then(() => {\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\tscrollIntoView(hash);\n\t\t\t\t});\n\t\t\t});\n\t\t} else {\n\t\t\tscrollIntoView(hash);\n\t\t}\n\t}, [currentRoute]);\n\n\tconst context = useMemo(\n\t\t() =>\n\t\t\t({\n\t\t\t\thash: hash,\n\t\t\t\tparams: params,\n\t\t\t\tcurrentRoute: currentRoute,\n\t\t\t\tsetNewRoute: setNewRoute,\n\t\t\t\troutes: routes,\n\t\t\t\troute: route,\n\t\t\t} as RouterContext),\n\t\t[currentRoute]\n\t);\n\n\tlet root: RouteStructure = { notFound: true } as any;\n\tif (route) {\n\t\troot = route;\n\t\tif (route.meta?.title) {\n\t\t\tdocument.title = route.meta.title;\n\t\t\tconst ogMeta = document.querySelector('meta[property=\"og:title\"]');\n\t\t\tif (ogMeta) ogMeta.setAttribute('content', route.meta.title);\n\t\t}\n\t\tif (route.meta?.description) {\n\t\t\tconst meta = document.querySelector('meta[name=\"description\"]');\n\t\t\tif (meta) meta.setAttribute('content', route.meta.description);\n\t\t\tconst ogMeta = document.querySelector('meta[property=\"og:description\"]');\n\t\t\tif (ogMeta) ogMeta.setAttribute('content', route.meta.description);\n\t\t}\n\t}\n\tlet nextRoute = null;\n\troot.nextRoute = nextRoute;\n\twhile (root.parent) {\n\t\tnextRoute = root;\n\t\troot = root.parent;\n\t\troot.nextRoute = nextRoute;\n\t}\n\n\tconst nextRouteCtx: RouterContext = useMemo(\n\t\t() => ({\n\t\t\t...context,\n\t\t\tsingleRoute: root,\n\t\t}),\n\t\t[currentRoute]\n\t);\n\n\treturn html`<${RouterContext.Provider} value=${context}>\n\t\t${\n\t\t\t(root as any).notFound\n\t\t\t\t? notFoundElement ?? html`<div class=\"wompo-router-not-found\">Not found!</div>`\n\t\t\t\t: getRouteContent(nextRouteCtx)\n\t\t}\n\t</${RouterContext.Provider}>`;\n}\n\ndefineWompo(Routes, {\n\tname: 'wompo-routes',\n});\n\n/* \n================================================================\nROUTE\n================================================================\n*/\n\ninterface RouteProps extends WompoProps {\n\tpath?: string;\n\tindex?: boolean;\n\tredirect?: string;\n\telement?: RenderHtml;\n\tlazy?: () => LazyCallbackResult;\n\tfallback?: RenderHtml;\n\troute?: RouteStructure;\n\tmeta?: {\n\t\ttitle?: string;\n\t\tdescription?: string;\n\t};\n}\n\n/**\n * This component is basically only used to create the routing tree structure. It will not render\n * anything, and will be deleted from the DOM after the `Routes` component has fully rendered.\n *\n * It accepts the following props:\n * - path?: the path of the current route. If it is a nested route, it shouldn't start with a slash.\n * - index?: If true, the route will be the index route of the parent. This is useful when you want\n *   a route to be a layout route.\n * - redirect?: if defined, the route will redirect the user to another path, without pushing the\n *   route in the history stack.\n * - element?: the element to render.\n * - lazy?: if defined, it must be a callback that returns a lazy Wompo component. This is very\n *   useful for performance optimizations, becasue every route will only be loaded when needed.\n * - fallback?: if the `lazy` prop is defined, this property will define what to render while the\n *   component to render is being fetched from the server.\n * - meta?: the metadata associated to the route. It's an object that accepts a title and a\n *   description key.\n */\nexport function Route(_: RouteProps) {\n\treturn html``;\n}\n\ndefineWompo(Route, {\n\tname: 'wompo-route',\n});\n\n/* \n================================================================\nCHILD-ROUTE\n================================================================\n*/\n/**\n * The `ChildRoute` component is the component responsible for building nested routes.\n * Each nested route will not render automatically: you need to use this component.\n *\n * Example:\n * Given the following routes:\n * ```javascript\n * function App(){\n *   return html`\n *     <${Routes}>\n * \t\t   <${Route} path=\"/\" component=${html`<${Home} />`} />\n * \t\t\t <${Route} path=\"/users\" component=${html`<${UsersDashboard} />`}>\n * \t\t\t\t <${Route} path=\":id\" component=${html`<${UserDetails} />`} />\n * \t\t\t\t <${Route} index component=${html`<${UsersList} />`} />\n * \t\t\t </${Route}>\n *     </${Routes}>\n *   `\n * }\n * ```\n *\n * The `UsersDashboard` component will look like this:\n * ```javascript\n * function UsersDashboard(){\n *   return html`\n *     ...\n *     <${ChildRoute} />\n *     ...\n *   `\n * }\n * ```\n *\n * The child route will allow to render the `UsersList` and the `UserDetails` components.\n */\nexport function ChildRoute() {\n\tconst router = useContext(RouterContext);\n\tconst route = router.singleRoute;\n\tlet toRender: RouteStructure = null;\n\tif (route) {\n\t\tconst newRoute = route.nextRoute;\n\t\tif (newRoute) {\n\t\t\ttoRender = newRoute;\n\t\t} else if (route.index) {\n\t\t\ttoRender = route.index;\n\t\t}\n\t}\n\tconst childRouter = useMemo(\n\t\t(): RouterContext =>\n\t\t\t({\n\t\t\t\t...router,\n\t\t\t\tsingleRoute: toRender,\n\t\t\t} as RouterContext),\n\t\t[router]\n\t);\n\n\treturn getRouteContent(childRouter);\n}\n\ndefineWompo(ChildRoute, {\n\tname: 'wompo-child-route',\n});\n\n/* \n================================================================\nLINK\n================================================================\n*/\ninterface LinkProps extends WompoProps {\n\tto: string;\n\ttarget?: string;\n}\n\nconst getHref = (to: string, route: RouteStructure, params: Params) => {\n\tlet href = to;\n\tif (!href.startsWith('/') && !href.startsWith('#') && route) {\n\t\tlet parentRoute = route;\n\t\twhile (parentRoute) {\n\t\t\tconst parentPath = parentRoute.path;\n\t\t\tif (parentPath) {\n\t\t\t\tlet parentRoutePath = parentPath;\n\t\t\t\tif (parentRoutePath.includes(':')) {\n\t\t\t\t\tconst paths = parentRoutePath.split('/');\n\t\t\t\t\tpaths\n\t\t\t\t\t\t.filter((p) => p.startsWith(':'))\n\t\t\t\t\t\t.map((p) => p.substring(1))\n\t\t\t\t\t\t.forEach((param) => {\n\t\t\t\t\t\t\tparentRoutePath = parentRoutePath.replace(`:${param}`, params[param]);\n\t\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tif (parentRoutePath.includes('*')) {\n\t\t\t\t\tparentRoutePath = parentRoutePath.replace('*', params.segments.join('/'));\n\t\t\t\t}\n\t\t\t\tconst slash = !parentRoutePath.endsWith('/') && !href.startsWith('/') ? '/' : '';\n\t\t\t\thref = parentRoutePath + slash + href;\n\t\t\t}\n\t\t\tparentRoute = parentRoute.parent;\n\t\t}\n\t}\n\treturn href;\n};\n\n/**\n * This component will render a link to navigate through the routes. You should use this component\n * instead of a simple `a` tag to navigate through your application, so that you use the pure client\n * routing system, without fetching the whole page through the server.\n *\n * It accepts the following props:\n * - to: required. The url of the link. If the link doesn't start with a slash (\"/\"), it will be\n *   positioned in the current route (e.g.: if the current route is \"/users\" and the `to` prop is\n *   \"20\", the link will go to \"/users/20\", not \"/20\").\n * - target: the target of the link.\n */\nexport function Link({ to, target, children }: LinkProps) {\n\tconst navigate = useNavigate();\n\tconst { singleRoute } = useContext(RouterContext);\n\tconst routes = useRoutes();\n\tconst params = useParams();\n\tconst href = getHref(to, singleRoute, params);\n\tconst onLinkClick = (ev: Event) => {\n\t\tif (!target) {\n\t\t\tev.preventDefault();\n\t\t\tnavigate(href);\n\t\t}\n\t};\n\tconst preload = () => {\n\t\tconst [route] = getMatch(routes, href.split('#')[0]);\n\t\tif (route && route.lazy) route.lazy();\n\t};\n\treturn html`<a\n\t\thref=${href}\n\t\ttarget=${target}\n\t\t@click=${onLinkClick}\n\t\t@mouseenter=${preload}\n\t\t@touchstart=${preload}\n\t>\n\t\t${children}\n\t</a>`;\n}\nLink.css = `:host { display: inline-block; }`;\ndefineWompo(Link, {\n\tname: 'wompo-link',\n});\n\n/* \n================================================================\nNAV-LINK\n================================================================\n*/\n/**\n * This component will render a link to navigate through the routes. You should use this component\n * instead of a simple `a` tag to navigate through your application, so that you use the pure client\n * routing system, without fetching the whole page through the server.\n *\n * The difference between the `Link` and `NavLink` is that the `NavLink` will have an \"active\" class\n * whenever the route associated with the link is actually the current one. This is useful to create\n * navbars and navigation links in general.\n *\n * It accepts the following props:\n * - to: required. The url of the link. If the link doesn't start with a slash (\"/\"), it will be\n *   positioned in the current route (e.g.: if the current route is \"/users\" and the `to` prop is\n *   \"20\", the link will go to \"/users/20\", not \"/20\").\n * - target: the target of the link.\n */\nexport function NavLink({ to, target, children }: LinkProps) {\n\tconst navigate = useNavigate();\n\tconst currentRoute = useCurrentRoute();\n\tconst params = useParams();\n\tconst routes = useRoutes();\n\tconst { singleRoute } = useContext(RouterContext);\n\tconst href = getHref(to, singleRoute, params);\n\tconst onLinkClick = (ev: Event) => {\n\t\tif (!target) {\n\t\t\tev.preventDefault();\n\t\t\tnavigate(href);\n\t\t}\n\t};\n\tconst preload = () => {\n\t\tconst [route] = getMatch(routes, href.split('#')[0]);\n\t\tif (route && route.lazy) route.lazy();\n\t};\n\tconst isActive = currentRoute === href;\n\treturn html`<a\n\t\tclass=${isActive && 'active'}\n\t\thref=${href}\n\t\ttarget=${target}\n\t\t@click=${onLinkClick}\n\t\t@mouseenter=${preload}\n\t\t@touchstart=${preload}\n\t>\n\t\t${children}\n\t</a>`;\n}\nNavLink.css = `:host { display: inline-block; }`;\n\ndefineWompo(NavLink, {\n\tname: 'wompo-nav-link',\n});\n\n/* \n================================================================\nHOOKS\n================================================================\n*/\n/**\n * This hook will return the current url parameters and search parameters of the current route.\n * Also, the components using this hook will automatically re-render whenver the current route\n * changes.\n */\nexport const useParams = () => {\n\tconst routerContext = useContext(RouterContext);\n\treturn routerContext.params;\n};\n\n/**\n * This hook will return function that can be used to manually navigate through the routes.\n * The function accepts two parameters: the new route (which has the same behavior of the \"to\" prop\n * in the `Link` component) and then a boolean value (default `true`) to indicate whether the new\n * route should be pushed or not in the history.\n */\nexport const useNavigate = () => {\n\tconst routerContext = useContext(RouterContext);\n\treturn routerContext.setNewRoute;\n};\n\n/**\n * This hook will return the current path, and will re-render the component whenever it changes.\n */\nexport const useCurrentRoute = () => {\n\tconst routerContext = useContext(RouterContext);\n\treturn routerContext.currentRoute;\n};\n\n/**\n * This hook will return all the data of the current route, and will re-render the component\n * whenever the current route changes.\n */\nexport const useRoute = () => {\n\tconst routerContext = useContext(RouterContext);\n\treturn routerContext.route;\n};\n\n/**\n * This hook will return the whole routes object that the `Routes` component uses to render the\n * correct routes.\n */\nexport const useRoutes = () => {\n\tconst routerContext = useContext(RouterContext);\n\treturn routerContext.routes;\n};\n"],
  "mappings": "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",
  "names": ["createContext", "defineWompo", "lazy", "useCallback", "useContext", "useEffect", "useMemo", "useState", "Suspense", "html", "buildTreeStructure", "origin", "childNodes", "structure", "parent", "child", "props", "lazyComp", "path", "route", "getRoutes", "treeStructure", "paths", "newRoute", "slash", "getWichParametricRouteisMoreSpecific", "routes", "parametricPaths", "a", "b", "matchA", "matchB", "dynamicsA", "key", "difference", "staticsA", "staticsB", "lengthDifference", "staticsALength", "staticsBLength", "i", "sA", "sB", "getSearchObject", "searchString", "params", "el", "value", "getMatch", "broswerRoute", "matches", "bRoute", "currentRoute", "search", "routeStructure", "routePath", "isFallback", "segments", "regex", "paramNames", "segment", "matchRegex", "routeToMatch", "match", "matchedSegment", "segmentsParam", "fallbackPaths", "redirect", "newPath", "getHref", "getRouteContent", "router", "RouterContext", "scrollIntoView", "hash", "element", "notFoundElement", "children", "setCurrentRoute", "setNewRoute", "pushState", "prevRoute", "nextRoute", "pathname", "context", "root", "ogMeta", "meta", "nextRouteCtx", "_", "toRender", "childRouter", "to", "href", "parentRoute", "parentPath", "parentRoutePath", "p", "param", "target", "navigate", "singleRoute", "onLinkClick", "ev", "preload"]
}
