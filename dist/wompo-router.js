import{createContext as N,defineWompo as C,lazy as F,useCallback as T,useContext as S,useEffect as A,useMemo as z,useState as q,Suspense as E,html as k}from"wompo";const j=(t,e,s=[],n=null)=>(e.forEach(c=>{if(c instanceof Route.class){const a=c.props,u=a.lazy?F(a.lazy):null,i=n===null&&t?(a.path.startsWith("/")?a.path.substring(0,a.path.length-1):a.path)+t:a.path,r={...a,parent:n,element:a.element,path:i,lazy:u,fallback:a.fallback,index:null,children:[]};a.index&&(n.index=r),s.push(r),j(t,c.childNodes,r.children,r)}}),s),B=(t,e=[],s="")=>{for(const n of t){let c="";if(n.path){const a=s&&!s.endsWith("/")||!s&&!n.path.startsWith("/")?"/":"";c+=s+a+n.path,e.push([c,n])}n.children&&B(n.children,e,c)}return e},H=t=>{const e=Object.keys(t);return e.sort((s,n)=>{const c=t[s],a=t[n],u=Object.keys(c).filter(o=>o!=="segments").length,r=Object.keys(a).filter(o=>o!=="segments").length-u;if(r===0){let o=s.split("/"),h=n.split("/");const y=h.length-o.length;if(y!==0)return y;let l=0,m=0;for(let p=0;p<o.length;p++){const g=o[p],x=h[p];if(g.startsWith(":")||l++,x.startsWith(":")||m++,g.startsWith(":")||x.startsWith(":")||g.startsWith("*")||x.startsWith("*"))break}return m-l}return r}),t[e[0]]},D=t=>{const e={};return t.split("&").forEach(s=>{const[n,c]=s.split("=");e[n]=c}),e},w=(t,e)=>{const s={exact:null,parametric:{},fallbacks:{}},n=e!=="/"&&e.endsWith("/")?e.substring(0,e.length-1):e;for(const r of t){const[o,h]=r,y=o.endsWith("*");if(!y&&o.split("/").length!==n.split("/").length)continue;if(o===n){s.exact=h;break}if(!o.includes(":")&&!o.includes("*"))continue;const l=o.split("/");let m="";const p=[];for(let d=1;d<l.length;d++){const f=l[d];m+="\\/",f.startsWith(":")?(d===l.length-1?m+="(.*)":m+="(.*?)",p.push(f.substring(1))):f==="*"?(m+="(.*)?",p.push("segments")):m+=f}const g=new RegExp(m,"g"),x=n+(m.endsWith("(.*)?")&&!n.endsWith("/")?"/":""),R=g.exec(x);if(R){const d={};for(let f=1;f<R.length;f++){let b=R[f]??"";if(b.includes("?")){const[$,M]=b.split("?");b=$,d.search=D(M)}if(p[f-1]==="segments"){const $=b?b.split("/"):[];$.pop(),d[p[f-1]]=$}else d[p[f-1]]=b}y?s.fallbacks[o]=[h,d]:s.parametric[o]=[h,d]}}const c=Object.keys(s.parametric),a=Object.keys(s.fallbacks);let u=[null,null];s.exact?u=[s.exact,{}]:c.length?u=H(s.parametric):a.length&&(u=H(s.fallbacks));const i=u[0]?.redirect||u[0]?.index?.redirect;if(i){const r=v(i,u[0],u[1]);history.replaceState({},void 0,r),u=w(t,r)}return u},O=t=>t?k`
		<${W.Provider} value=${{...t}}>
			${t.lazy?t.fallback?k`
							<${E} fallback=${t.fallback}>
								<${t.lazy} />
							</${E}>
						`:k`<${t.lazy} />`:t.element}
		</${W.Provider}>
	`:null,P=N({params:null,hash:null,currentRoute:null,setNewRoute:null,routes:[]}),L=t=>{if(t){const e=document.getElementById(t);e&&e.scrollIntoView({block:"start",behavior:"smooth"})}};export function Routes({origin:t,notFoundElement:e,children:s}){const[n,c]=q(window.location.pathname),a=z(()=>j(t,s.nodes),[]),u=z(()=>B(a),[]),i=window.location.hash.split("#")[1],[r,o]=w(u,n),h=T((p,g=!0)=>{c(x=>{const R=v(p,r,o),[d,f]=R.split("#");return g&&x!==R?history.pushState({},null,R):!g&&x!==R&&history.replaceState({},null,R),L(f),R.startsWith("#")?x:d})},[r,o]);A(()=>{window.addEventListener("popstate",()=>{h(window.location.pathname,!1)})},[]),A(()=>{window.scrollTo(0,0),r?.lazy?r.lazy().then(()=>{setTimeout(()=>{L(i)})}):L(i)},[n]);const y=z(()=>({hash:i,params:o,currentRoute:n,setNewRoute:h,routes:u}),[n]);let l={notFound:!0};if(r){if(l=r,r.meta?.title){document.title=r.meta.title;const p=document.querySelector('meta[property="og:title"]');p&&p.setAttribute("content",r.meta.title)}if(r.meta?.description){const p=document.querySelector('meta[name="description"]');p&&p.setAttribute("content",r.meta.description);const g=document.querySelector('meta[property="og:description"]');g&&g.setAttribute("content",r.meta.description)}}let m=null;for(l.nextRoute=m;l.parent;)m=l,l=l.parent,l.nextRoute=m;return k`<${P.Provider} value=${y}>
		${l.notFound?e??k`<div class="wompo-router-not-found">Not found!</div>`:O(l)}
	</${P.Provider}>`}C(Routes,{name:"womp-routes"});const W=N(null);export function Route(t){return k``}C(Route,{name:"wompo-route"});export function ChildRoute(){const t=S(W);let e=null;if(t){const s=t.nextRoute;s?e=s:t.index&&(e=t.index)}return O(e)}C(ChildRoute,{name:"wompo-child-route"});const v=(t,e,s)=>{let n=t;if(!n.startsWith("/")&&!n.startsWith("#")&&e){let c=e;for(;c;){const a=c.path;if(a){const u=a.endsWith("/")?"":"/";let i=a;i.includes(":")&&i.split("/").filter(o=>o.startsWith(":")).map(o=>o.substring(1)).forEach(o=>{i=i.replace(`:${o}`,s[o])}),i.includes("*")&&(i=i.replace("*",s.segments.join("/"))),n=i+u+n}c=c.parent}}return n};export function Link({to:t,target:e,children:s}){const n=useNavigate(),c=S(W),a=useRoutes(),u=useParams(),i=v(t,c,u),r=h=>{e||(h.preventDefault(),n(i))},o=()=>{const[h]=w(a,i.split("#")[0]);h&&h.lazy&&h.lazy()};return k`<a
		href=${i}
		target=${e}
		@click=${r}
		@mouseenter=${o}
		@touchstart=${o}
	>
		${s}
	</a>`}Link.css=":host { display: inline-block; }",C(Link,{name:"wompo-link"});export function NavLink({to:t,target:e,children:s}){const n=useNavigate(),c=useCurrentRoute(),a=useParams(),u=useRoutes(),i=S(W),r=v(t,i,a),o=l=>{e||(l.preventDefault(),n(r))},h=()=>{const[l]=w(u,r.split("#")[0]);l&&l.lazy&&l.lazy()};return k`<a
		class=${c===r&&"active"}
		href=${r}
		target=${e}
		@click=${o}
		@mouseenter=${h}
		@touchstart=${h}
	>
		${s}
	</a>`}NavLink.css=":host { display: inline-block; }",C(NavLink,{name:"wompo-nav-link"});export const useParams=()=>S(P).params,useNavigate=()=>S(P).setNewRoute,useCurrentRoute=()=>S(P).currentRoute,useRoutes=()=>S(P).routes;
