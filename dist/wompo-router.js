import{createContext as E,defineWompo as w,lazy as T,useCallback as q,useContext as b,useEffect as j,useMemo as L,useState as D,Suspense as B,html as k}from"wompo";const H=(t,n,s=[],o=null)=>(n.forEach(r=>{if(r instanceof Route.class){const a=r.props,i=a.lazy?T(a.lazy):null,m=o===null&&t?(a.path.startsWith("/")?a.path.substring(0,a.path.length-1):a.path)+t:a.path,e={...a,parent:o,element:a.element,path:m,lazy:i,fallback:a.fallback,index:null,children:[]};a.index&&(o.index=e),s.push(e),H(t,r.childNodes,e.children,e)}}),s),O=(t,n=[],s="")=>{for(const o of t){let r="";if(o.path){const a=s&&!s.endsWith("/")||!s&&!o.path.startsWith("/")?"/":"";r+=s+a+o.path,n.push([r,o])}o.children&&O(o.children,n,r)}return n},M=t=>{const n=Object.keys(t);return n.sort((s,o)=>{const r=t[s],a=t[o],i=Object.keys(r).filter(c=>c!=="segments").length,e=Object.keys(a).filter(c=>c!=="segments").length-i;if(e===0){let c=s.split("/"),l=o.split("/");const f=l.length-c.length;if(f!==0)return f;let u=0,R=0;for(let p=0;p<c.length;p++){const h=c[p],d=l[p];if(h.startsWith(":")||u++,d.startsWith(":")||R++,h.startsWith(":")||d.startsWith(":")||h.startsWith("*")||d.startsWith("*"))break}return R-u}return e}),t[n[0]]},I=t=>{if(!t)return{};const n={};return t.split("&").forEach(s=>{const[o,r]=s.split("=");n[o]=r}),n},C=(t,n)=>{const s={exact:null,parametric:{},fallbacks:{}},o=n!=="/"&&n.endsWith("/")?n.substring(0,n.length-1):n,[r,a]=o.split("?");for(const l of t){const[f,u]=l,R=f.endsWith("*");if(!R&&f.split("/").length!==r.split("/").length)continue;if(f===r){s.exact=u;break}if(!f.includes(":")&&!f.includes("*"))continue;const p=f.split("/");let h="";const d=[];for(let x=1;x<p.length;x++){const g=p[x];h+="\\/",g.startsWith(":")?(x===p.length-1?h+="(.*)":h+="(.*?)",d.push(g.substring(1))):g==="*"?(h+="(.*)?",d.push("segments")):h+=g}const y=new RegExp(h,"g"),v=r+(h.endsWith("(.*)?")&&!r.endsWith("/")?"/":""),S=y.exec(v);if(S){const x={};for(let g=1;g<S.length;g++){let z=S[g]??"";if(d[g-1]==="segments"){const A=z?z.split("/"):[];A.pop(),x[d[g-1]]=A}else x[d[g-1]]=z}R?s.fallbacks[f]=[u,x]:s.parametric[f]=[u,x]}}const i=Object.keys(s.parametric),m=Object.keys(s.fallbacks);let e=[null,null];s.exact?e=[s.exact,{}]:i.length?e=M(s.parametric):m.length&&(e=M(s.fallbacks));const c=e[0]?.redirect||e[0]?.index?.redirect;if(c){const l=$(c,e[0],e[1]);history.replaceState({},void 0,l),e=C(t,l)}return e[1]&&(e[1].search=I(a)),e},F=t=>t?k`
		<${W.Provider} value=${{...t}}>
			${t.lazy?t.fallback?k`
							<${B} fallback=${t.fallback}>
								<${t.lazy} />
							</${B}>
						`:k`<${t.lazy} />`:t.element}
		</${W.Provider}>
	`:null,P=E({params:null,hash:null,currentRoute:null,setNewRoute:null,routes:[]}),N=t=>{if(t){const n=document.getElementById(t);n&&n.scrollIntoView({block:"start",behavior:"smooth"})}};export function Routes({origin:t,notFoundElement:n,children:s}){const[o,r]=D(window.location.pathname+window.location.search),a=L(()=>H(t,s.nodes),[]),i=L(()=>O(a),[]),m=window.location.hash.split("#")[1],[e,c]=C(i,o),l=q((p,h=!0)=>{r(d=>{const y=$(p,e,c),[v,S]=y.split("#");return h&&d!==y?history.pushState({},null,y):!h&&d!==y&&history.replaceState({},null,y),N(S),y.startsWith("#")?d:v})},[e,c]);j(()=>{window.addEventListener("popstate",()=>{l(window.location.pathname,!1)})},[]),j(()=>{window.scrollTo(0,0),e?.lazy?e.lazy().then(()=>{setTimeout(()=>{N(m)})}):N(m)},[o]);const f=L(()=>({hash:m,params:c,currentRoute:o,setNewRoute:l,routes:i}),[o]);let u={notFound:!0};if(e){if(u=e,e.meta?.title){document.title=e.meta.title;const p=document.querySelector('meta[property="og:title"]');p&&p.setAttribute("content",e.meta.title)}if(e.meta?.description){const p=document.querySelector('meta[name="description"]');p&&p.setAttribute("content",e.meta.description);const h=document.querySelector('meta[property="og:description"]');h&&h.setAttribute("content",e.meta.description)}}let R=null;for(u.nextRoute=R;u.parent;)R=u,u=u.parent,u.nextRoute=R;return k`<${P.Provider} value=${f}>
		${u.notFound?n??k`<div class="wompo-router-not-found">Not found!</div>`:F(u)}
	</${P.Provider}>`}w(Routes,{name:"womp-routes"});const W=E(null);export function Route(t){return k``}w(Route,{name:"wompo-route"});export function ChildRoute(){const t=b(W);let n=null;if(t){const s=t.nextRoute;s?n=s:t.index&&(n=t.index)}return F(n)}w(ChildRoute,{name:"wompo-child-route"});const $=(t,n,s)=>{let o=t;if(!o.startsWith("/")&&!o.startsWith("#")&&n){let r=n;for(;r;){const a=r.path;if(a){let i=a;i.includes(":")&&i.split("/").filter(c=>c.startsWith(":")).map(c=>c.substring(1)).forEach(c=>{i=i.replace(`:${c}`,s[c])}),i.includes("*")&&(i=i.replace("*",s.segments.join("/")));const m=!i.endsWith("/")&&!o.startsWith("/")?"/":"";o=i+m+o}r=r.parent}}return o};export function Link({to:t,target:n,children:s}){const o=useNavigate(),r=b(W),a=useRoutes(),i=useParams(),m=$(t,r,i),e=l=>{n||(l.preventDefault(),o(m))},c=()=>{const[l]=C(a,m.split("#")[0]);l&&l.lazy&&l.lazy()};return k`<a
		href=${m}
		target=${n}
		@click=${e}
		@mouseenter=${c}
		@touchstart=${c}
	>
		${s}
	</a>`}Link.css=":host { display: inline-block; }",w(Link,{name:"wompo-link"});export function NavLink({to:t,target:n,children:s}){const o=useNavigate(),r=useCurrentRoute(),a=useParams(),i=useRoutes(),m=b(W),e=$(t,m,a),c=u=>{n||(u.preventDefault(),o(e))},l=()=>{const[u]=C(i,e.split("#")[0]);u&&u.lazy&&u.lazy()};return k`<a
		class=${r===e&&"active"}
		href=${e}
		target=${n}
		@click=${c}
		@mouseenter=${l}
		@touchstart=${l}
	>
		${s}
	</a>`}NavLink.css=":host { display: inline-block; }",w(NavLink,{name:"wompo-nav-link"});export const useParams=()=>b(P).params,useNavigate=()=>b(P).setNewRoute,useCurrentRoute=()=>b(P).currentRoute,useRoutes=()=>b(P).routes;
